// Test if a new solution can be added for contract - SolnSquareVerifier

// Test if an ERC721 token can be minted for contract - SolnSquareVerifier
const fs = require('fs')
var SolnSquareVerifier = artifacts.require('./SolnSquareVerifier.sol');
var Verifier = artifacts.require('./Verifier.sol');

const TURI = "https://s3-us-west-2.amazonaws.com/udacity-blockchain/capstone/";
const symbol = "URE";
const Cname = "Udacity Real Estate"
const NUM_TOKENS = 10
// define a variable to import the <Verifier> or <renamedVerifier> solidity contract generated by Zokrates
contract('Verifier', async(accounts) => {
    var conf;
    var proof;
    var inp;
    var solnSquareVerifier;
    before('setup contract', async () =>{
        proof = JSON.parse(fs.readFileSync('../zokrates/code/square/proof.json'));
        inp = proof.inputs;
        proof = proof.proof
        verifier = await Verifier.new();
        solnSquareVerifier = await SolnSquareVerifier.new(verifier.address, Cname, symbol, TURI);
    });
    describe ('matching ERC 721 spec', () => {
        it('adding a new solution', async() => {
            let token = 1;
            await solnSquareVerifier.addSolution(
                proof.a,
                proof.b,
                proof.c,
                inp,
                accounts[0],
                token, {from: accounts[0]}
            )


        })
        it('token can be minted after it is verified', async() =>{
        //let's swap a and b and see what happens
        let token = 1;
        let status = await solnSquareVerifier.mintProof.call(accounts[0], token);
        assert.equal(status, true, "token would not be minted");
    });
    it('trying to mint a token before it is verified', async() =>{
        //let's swap a and b and see what happens
        let token = 2;
        let reverted = false;
        try{
        let status = await solnSquareVerifier.mintProof(accounts[0], token);
        
        }
        catch(e) {reverted = true;} 
        assert.equal(reverted, true, "token would not be minted");
    });
    it('trying to mint a token that already exists', async() =>{
        //let's swap a and b and see what happens
        let token = 1;
        let reverted = false;

        //minting token
        let status = await solnSquareVerifier.mintProof(accounts[0], token);
        try{
        let status = await solnSquareVerifier.mintProof(accounts[0], token);
        }
        catch(e) {reverted = true} 
        assert.equal(reverted, true, "same token could not be minted");
    });




    });
});
